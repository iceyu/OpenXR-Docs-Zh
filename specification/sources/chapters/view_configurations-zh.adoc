// Copyright (c) 2016-2022, The Khronos Group Inc.
//
// SPDX-License-Identifier: CC-BY-4.0
[[view_configurations]]
== View Configurations（视图配置）

一个 **view configuration（视图配置** 是一个 具有 语义意义 上 指出一个或多个可以被一个应用程序可以为其渲染图像的的视图的集合

一个  **primary view configuration（主视图配置）** 是一个视图配置，其 旨在呈现给 可与XR应用程序进行交互的观察者 。

这种区别允许以后添加其他视图，例如为观众准备的视图。

典型的头戴式 VR 系统具有一个拥有两个视图的视图配置，而典型的基于手机的 AR 系统的视图配置只有一个拥有单个视图的视图配置。

一个简单的基于投影的多面（类似 CAVE） VR 系统可能有一个视图配置，其在房间里每个显示表面（墙壁、地板、
天花板）都具有至少一个视图。

对于任何受支持的规格，系统将支持一个或多个主视图配置。

如果系统支持针对硬件优化的特殊视图配置，但为了兼容性还支持更广泛使用的视图配置
，那么支持多个主视图配置可能就很有用。

视图配置通过 elink:XrViewConfigurationType 标识。


[[view_configuration_type]]
=== Primary View Configurations（主视图配置

[open,refpage='XrViewConfigurationType',desc='Supported view configuration type',type='enums']
--
include::../../generated/api/enums/XrViewConfigurationType.txt[]

当调用 flink:xrBeginSession 时， 应用程序选择 主视图 类型，并且在 会话的生命周期中此配置保持不变，直到 flink:xrEndSession 被调用。


视图的数量 和每个视图索引的语义含义 给了视图配置 明确的定义，下面为所有核心视图配置做了明确规定。

预定义 的 主视图配置 类型是：

.Enumerant Descriptions
****
* ename:XR_VIEW_CONFIGURATION_TYPE_PRIMARY_MONO.
  One view representing the form factor's one primary display.
  For example, an AR phone's screen.
  This configuration requires one element in
  slink:XrViewConfigurationProperties and one projection in each
  slink:XrCompositionLayerProjection layer.
* ename:XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO.
  Two views representing the form factor's two primary displays, which map
  to a left-eye and right-eye view.
  This configuration requires two views in
  slink:XrViewConfigurationProperties and two views in each
  slink:XrCompositionLayerProjection layer.
  View index 0 must: represent the left eye and view index 1 must: represent
  the right eye.
****
--

[[view_configuration_api]]
=== 视图配置 API

首先，应用程序需要选择它要使用的主视图配置。

如果支持多配置，在创建 slink:XrSession前 应用程序要调用flink:xrEnumerateViewConfigurations  来 获得给定 系统支持的视图配置类型的列表。

应用程序可以调用 flink:xrGetViewConfigurationProperties 和
flink:xrEnumerateViewConfigurationViews 来获得每个 视图配置类型和它各自视图 的详细信息。


==== xrEnumerateViewConfigurations

[open,refpage='xrEnumerateViewConfigurations',desc='Enumerates supported view configurations',type='protos',xrefs='XrViewConfigurationType']
--
The flink:xrEnumerateViewConfigurations function is defined as:

include::../../generated/api/protos/xrEnumerateViewConfigurations.txt[]

.Parameter Descriptions
****
* pname:instance is the instance from which pname:systemId was retrieved.
* pname:systemId is the basetype:XrSystemId whose view configurations will
  be enumerated.
* pname:viewConfigurationsTypeCapacityInput is the capacity of the
  pname:viewConfigurations array, or 0 to indicate a request to retrieve the
  required capacity.
* pname:viewConfigurationsTypeCountOutput is a pointer to the count of
  pname:viewConfigurations written, or a pointer to the required capacity in
  the case that pname:viewConfigurationsTypeCapacityInput is 0.
* pname:viewConfigurationsTypes is a pointer to an array of
  elink:XrViewConfigurationType values, but can: be code:NULL if
  pname:viewConfigurationsTypeCapacityInput is 0.
* See <<buffer-size-parameters, Buffer Size Parameters>> chapter for a
  detailed description of retrieving the required pname:viewConfigurations
  size.
****

flink:xrEnumerateViewConfigurations enumerates the view configuration types
supported by the basetype:XrSystemId.
The supported set for that system must: not change during the lifetime of
its slink:XrInstance.
The returned list of primary view configurations should: be in order from
what the runtime considered highest to lowest user preference.
Thus the first enumerated view configuration type should: be the one the
runtime prefers the application to use if possible.

Runtimes must: always return identical buffer contents from this enumeration
for the given pname:systemId and for the lifetime of the instance.

include::../../generated/validity/protos/xrEnumerateViewConfigurations.txt[]
--

==== xrGetViewConfigurationProperties

[open,refpage='xrGetViewConfigurationProperties',desc='Gets information for a view configuration',type='protos',xrefs='XrViewConfigurationType XrViewConfigurationProperties']
--
The flink:xrGetViewConfigurationProperties function is defined as:

include::../../generated/api/protos/xrGetViewConfigurationProperties.txt[]

.Parameter Descriptions
****
* pname:instance is the instance from which pname:systemId was retrieved.
* pname:systemId is the basetype:XrSystemId whose view configuration is
  being queried.
* pname:viewConfigurationType is the elink:XrViewConfigurationType of the
  configuration to get.
* pname:configurationProperties is a pointer to view configuration
  properties to return.
****

flink:xrGetViewConfigurationProperties queries properties of an individual
view configuration.
Applications must: use one of the supported view configuration types
returned by flink:xrEnumerateViewConfigurations.
If pname:viewConfigurationType is not supported by this slink:XrInstance the
runtime must: return ename:XR_ERROR_VIEW_CONFIGURATION_TYPE_UNSUPPORTED.

include::../../generated/validity/protos/xrGetViewConfigurationProperties.txt[]
--

==== XrViewConfigurationProperties

[open,refpage='XrViewConfigurationProperties',desc='Detailed configuration properties for an XrViewConfigurationProperties',type='structs',xrefs='XrViewConfigurationType xrGetViewConfigurationProperties XrViewConfigurationView']
--

The slink:XrViewConfigurationProperties structure is defined as:
include::../../generated/api/structs/XrViewConfigurationProperties.txt[]

.Member Descriptions
****
* pname:type is the elink:XrStructureType of this structure.
* pname:next is code:NULL or a pointer to the next structure in a structure
  chain.
  No such structures are defined in core OpenXR.
* pname:viewConfigurationType is the elink:XrViewConfigurationType of the
  configuration.
* pname:fovMutable indicates if the view field of view can be modified by
  the application.
****

include::../../generated/validity/structs/XrViewConfigurationProperties.txt[]
--

==== xrEnumerateViewConfigurationViews

[open,refpage='xrEnumerateViewConfigurationViews',desc='Gets view configuration views',type='protos',xrefs='XrViewConfigurationType xrGetViewConfigurationProperties XrViewConfigurationView']
--
The flink:xrEnumerateViewConfigurationViews function is defined as:

include::../../generated/api/protos/xrEnumerateViewConfigurationViews.txt[]

.Parameter Descriptions
****
* pname:instance is the instance from which pname:systemId was retrieved.
* pname:systemId is the basetype:XrSystemId whose view configuration is
  being queried.
* pname:viewConfigurationType is the elink:XrViewConfigurationType of the
  configuration to get.
* pname:viewCapacityInput is the capacity of the pname:views array, or 0 to
  indicate a request to retrieve the required capacity.
* pname:viewCountOutput is a pointer to the count of pname:views written, or
  a pointer to the required capacity in the case that
  pname:viewCapacityInput is 0.
* pname:views is a pointer to an array of slink:XrViewConfigurationView
  values, but can: be code:NULL if pname:viewCapacityInput is 0.
****

Each elink:XrViewConfigurationType defines the number of views associated
with it.
Applications can query more details of each view element using
flink:xrEnumerateViewConfigurationViews.
If the supplied pname:viewConfigurationType is not supported by this
slink:XrInstance and basetype:XrSystemId, the runtime must: return
ename:XR_ERROR_VIEW_CONFIGURATION_TYPE_UNSUPPORTED.

Runtimes must: always return identical buffer contents from this enumeration
for the given pname:systemId and pname:viewConfigurationType for the
lifetime of the instance.

include::../../generated/validity/protos/xrEnumerateViewConfigurationViews.txt[]
--

==== XrViewConfigurationView

[open,refpage='XrViewConfigurationView',desc='Individual view configuration',type='structs',xrefs='XrViewConfigurationType xrEnumerateViewConfigurationViews XrViewConfigurationProperties']
--
Each slink:XrViewConfigurationView specifies properties related to rendering
of an individual view within a view configuration.

The slink:XrViewConfigurationView structure is defined as:
include::../../generated/api/structs/XrViewConfigurationView.txt[]

.Member Descriptions
****
* pname:type is the elink:XrStructureType of this structure.
* pname:next is code:NULL or a pointer to the next structure in a structure
  chain.
  No such structures are defined in core OpenXR.
* pname:recommendedImageRectWidth is the optimal width of pname:imageRect to
  use when rendering this view into a swapchain.
* pname:maxImageRectWidth is the maximum width of pname:imageRect supported
  when rendering this view into a swapchain.
* pname:recommendedImageRectHeight is the optimal height of pname:imageRect
  to use when rendering this view into a swapchain.
* pname:maxImageRectHeight is the maximum height of pname:imageRect
  supported when rendering this view into a swapchain.
* pname:recommendedSwapchainSampleCount is the recommended number of
  sub-data element samples to create for each swapchain image that will be
  rendered into for this view.
* pname:maxSwapchainSampleCount is the maximum number of sub-data element
  samples supported for swapchain images that will be rendered into for this
  view.
****

See slink:XrSwapchainSubImage for more information about pname:imageRect
values, and slink:XrSwapchainCreateInfo for more information about creating
swapchains appropriately sized to support those pname:imageRect values.

The array of slink:XrViewConfigurationView returned by the runtime must:
adhere to the rules defined in <<view_configuration_type,
elink:XrViewConfigurationType>>, such as the count and association to the
left and right eyes.

include::../../generated/validity/structs/XrViewConfigurationView.txt[]
--

[[example_view_configurations_code]]
=== Example View Configuration Code

// see view_configuration.0.h
[source,C++]
----
XrInstance instance; // previously initialized
XrSystemId system;   // previously initialized
XrSession session;   // previously initialized
XrSpace sceneSpace;  // previously initialized

// Enumerate the view configurations paths.
uint32_t configurationCount;
CHK_XR(xrEnumerateViewConfigurations(instance, system, 0, &configurationCount, nullptr));

std::vector<XrViewConfigurationType> configurationTypes(configurationCount);
CHK_XR(xrEnumerateViewConfigurations(instance, system, configurationCount, &configurationCount, configurationTypes.data()));

bool configFound = false;
for(uint32_t i = 0; i < configurationCount; ++i)
{
    if (configurationTypes[i] == XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO)
    {
        configFound = true;
        break;  // Pick the first supported, i.e. preferred, view configuration.
    }
}

if (!configFound)
    return;   // Cannot support any view configuration of this system.

// Get detailed information of each view element.
uint32_t viewCount;
CHK_XR(xrEnumerateViewConfigurationViews(instance, system,
    XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO,
    0,
    &viewCount,
    nullptr));

std::vector<XrViewConfigurationView> configViews(viewCount, {XR_TYPE_VIEW_CONFIGURATION_VIEW});
CHK_XR(xrEnumerateViewConfigurationViews(instance, system,
    XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO,
    viewCount,
    &viewCount,
    configViews.data()));

// Set the primary view configuration for the session.
XrSessionBeginInfo beginInfo = {XR_TYPE_SESSION_BEGIN_INFO};
beginInfo.primaryViewConfigurationType = XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO;
CHK_XR(xrBeginSession(session, &beginInfo));

// Allocate a buffer according to viewCount.
std::vector<XrView> views(viewCount, {XR_TYPE_VIEW});

// Run a per-frame loop.
while (!quit)
{
    // Wait for a new frame.
    XrFrameWaitInfo frameWaitInfo{XR_TYPE_FRAME_WAIT_INFO};
    XrFrameState frameState{XR_TYPE_FRAME_STATE};
    CHK_XR(xrWaitFrame(session, &frameWaitInfo, &frameState));

    // Begin frame immediately before GPU work
    XrFrameBeginInfo frameBeginInfo { XR_TYPE_FRAME_BEGIN_INFO };
    CHK_XR(xrBeginFrame(session, &frameBeginInfo));

    std::vector<XrCompositionLayerBaseHeader*> layers;
    XrCompositionLayerProjectionView projViews[2] = { /*...*/ };
    XrCompositionLayerProjection layerProj{ XR_TYPE_COMPOSITION_LAYER_PROJECTION};

    if (frameState.shouldRender) {
        XrViewLocateInfo viewLocateInfo{XR_TYPE_VIEW_LOCATE_INFO};
        viewLocateInfo.displayTime = frameState.predictedDisplayTime;
        viewLocateInfo.space = sceneSpace;

        XrViewState viewState{XR_TYPE_VIEW_STATE};
        XrView views[2] = { {XR_TYPE_VIEW}, {XR_TYPE_VIEW}};
        uint32_t viewCountOutput;
        CHK_XR(xrLocateViews(session, &viewLocateInfo, &viewState, configViews.size(), &viewCountOutput, views));

        // ...
        // Use viewState and frameState for scene render, and fill in projViews[2]
        // ...

        // Assemble composition layers structure
        layerProj.layerFlags = XR_COMPOSITION_LAYER_BLEND_TEXTURE_SOURCE_ALPHA_BIT;
        layerProj.space = sceneSpace;
        layerProj.viewCount = 2;
        layerProj.views = projViews;
        layers.push_back(reinterpret_cast<XrCompositionLayerBaseHeader*>(&layerProj));
    }

    // End frame and submit layers, even if layers is empty due to shouldRender = false
    XrFrameEndInfo frameEndInfo{ XR_TYPE_FRAME_END_INFO};
    frameEndInfo.displayTime = frameState.predictedDisplayTime;
    frameEndInfo.environmentBlendMode = XR_ENVIRONMENT_BLEND_MODE_OPAQUE;
    frameEndInfo.layerCount = (uint32_t)layers.size();
    frameEndInfo.layers = layers.data();
    CHK_XR(xrEndFrame(session, &frameEndInfo));
}

----

